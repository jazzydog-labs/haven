# Haven – Alembic Migration Workflow

*Last updated: 2025-07-16*

This guide explains how Haven manages schema evolution with **Alembic 1.13**: naming conventions, branching strategy, squash policy, and the Justfile helpers that tie it all together.

> **Note:** For containerized migration strategies, see [Migration Strategies Guide](migration-strategies.md).

---

## 1  Core Principles

1. **One-way street** – Migrations are append‑only; never edit a committed revision.
2. **Single head** – `main` always points to a *linear* migration history. Feature branches may diverge but must rebase or merge‑squash before landing.
3. **Squash responsibly** – periodic squashes keep the chain readable but happen only at safe milestones (details § 6).
4. **Async‑ready** – We use `sqlalchemy.ext.asyncio` models; migrations run synchronously with *offline* mode for scripted upgrades, *online* for local dev.

---

## 2  Directory Layout

```
src/haven/infrastructure/database/
├── models.py             # SQLAlchemy ORM models
└── migrations/
    ├── env.py            # Alembic config (async engine)
    ├── versions/
    │   ├── 20250715_01_initial.py
    │   └── ...
    └── script.py.mako    # revision file template
```

The Alembic section is isolated inside the package so importing models from `env.py` is straightforward.

---

## 3  Naming & Revision ID Conventions

* **Filename**: `{YYYYMMDD}_{NN}_{slug}.py` (two‑digit daily sequence).
* **Revision ID**: autogenerated 12-character SHA, left as‑is.
* **Message**: imperative present‑tense ("add record table").

Example command:

```bash
just database::make "add tag column to record"
# Creates versions/20250715_02_add_tag_column_to_record.py
```

`db-make` is a Justfile wrapper for `alembic revision --autogenerate -m`.

---

## 4  Creating a Migration (local dev)

1. Ensure Postgres is running: `just database::up`.
2. Edit or add models in `models.py`.
3. Run `just database::make "<message>"`.
4. **Review** the generated file—especially `op.add_column` / `op.drop_column` statements.
5. Upgrade your dev DB: `just database::migrate`.
6. Run tests: `just test`.

> If Alembic generates a *noop* (no schema diff) verify `__tablename__` and field types; then rerun.

---

## 5  Branching Strategy

* **Feature branch** creates migrations as needed (1–n revisions).
* Before merge into `main`, **rebase** on latest `main` so your head is descendant of the tip.
* Resolve conflicts by regenerating (`just database::make`) after rebase, or manually editing versions.

The goal is **one canonical head**; Alembic will complain if multiple heads exist.

---

## 6  Squash Policy

Squash migrations when **either** condition is met:

1. **500‑line threshold** – accumulated migration scripts exceed 500 LOC.
2. **Major release** – before tagging `v0.x.0`, to freeze legacy chain.

### How to squash

```bash
# 1. Identify the range to squash
alembic history  # Note first and last revision IDs

# 2. Create new consolidated migration
alembic revision -m "squash migrations up to 2025-07-15"

# 3. In the new file, consolidate all operations:
```

```python
"""squash migrations up to 2025-07-15

Revision ID: abc123def456
Revises: None
Create Date: 2025-07-15 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'abc123def456'
down_revision = None  # This becomes the new base
branch_labels = None
depends_on = None

def upgrade():
    # Consolidated operations from all squashed migrations
    op.create_table('record',
        sa.Column('id', sa.UUID(), nullable=False),
        sa.Column('title', sa.String(255), nullable=False),
        sa.Column('created_at', sa.DateTime(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    
    op.create_table('tag',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(50), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    
    op.add_column('record', sa.Column('tag_id', sa.Integer(), nullable=True))
    op.create_foreign_key('fk_record_tag', 'record', 'tag', ['tag_id'], ['id'])
    # ... continue with all schema changes up to this point

def downgrade():
    raise NotImplementedError("Squashed migrations cannot be downgraded")
```

```bash
# 4. Update alembic_version table in production before deploying
UPDATE alembic_version SET version_num = 'abc123def456';

# 5. Archive old migrations to migrations/archive/ directory
```

*Tests* must target a DB seeded by the new squash. Remove deprecated scripts in a subsequent commit once all environments have deployed the squashed version.

---

## 7  Production Migration Strategy

Production migrations follow a careful process:

1. **Pre-deployment**: Migrations are applied as a separate job before app deployment
2. **Migration job**: Runs `just database::migrate-prod` which uses offline mode
3. **Long migrations**: For DDL that takes >30s, schedule maintenance window
4. **Verification**: Health checks confirm schema version matches app expectations

Never run migrations on app startup in production—this causes race conditions with multiple replicas.

---

## 8  Rollbacks

Alembic downgrade is **disabled** in production (irreversible migrations). However, local dev can roll back one step:

```bash
just database::downgrade 1
```

This runs `alembic downgrade -1` against the dev DB. Use with caution—data loss likely.

---

## 9  Justfile Commands Recap

```text
db-up               – docker compose up -d postgres
db-down             – docker compose down
db-migrate          – alembic upgrade head
db-migrate-offline  – alembic upgrade head --sql (prints SQL without executing)
db-make <msg>       – alembic revision --autogenerate -m <msg>
db-downgrade <n>    – alembic downgrade -<n>
db-history          – alembic history --verbose
db-current          – alembic current
```

All commands respect `DATABASE_URL` from your `.env` or Hydra config.

---

~~## 10  CI / CD Hooks~~

~~* **PR checks** run `just database::migrate-offline` to verify migrations generate valid SQL without touching DB.~~
~~* **Integration tests** spin up a fresh Postgres, apply migrations, and exercise repositories.~~
~~* **Production deploy** runs migrations in a separate job before rolling out new app version.~~

We are not doing CI/CD for now.

---

## 11  Handling Failed Migrations

If a migration fails midway:

1. **Local dev**: Drop and recreate the database, then reapply all migrations
   ```bash
   just db-down && just database::up && just database::migrate
   ```

2. **Staging**: Restore from backup, fix the migration, reapply
   ```bash
   # Restore DB backup
   # Fix migration file
   just database::migrate
   ```

3. **Production**: Requires careful manual intervention
   - Check `alembic current` to see partially applied state
   - Review transaction logs to understand what succeeded
   - Contact @haven-maintainers before manual fixes

Never attempt to manually edit the `alembic_version` table unless you fully understand the implications.

---

## 12  Troubleshooting

* **Multiple heads detected** – run `alembic heads`, rebase, regenerate.
* **Target database is not up‑to‑date** – ensure CI ran `just database::migrate` or run it locally.
* **Autogenerate misses diff** – compare metadata binds; ensure all models import inside `env.py`.
* **"Can't locate revision"** – check if you need to pull latest migrations from `main`.
* **Async engine errors** – remember migrations run synchronously; the async engine is adapted in `env.py`.

---

For deep dives into Alembic patterns, see [https://alembic.sqlalchemy.org/en/latest/branches.html](https://alembic.sqlalchemy.org/en/latest/branches.html) and [https://alembic.sqlalchemy.org/en/latest/cookbook.html](https://alembic.sqlalchemy.org/en/latest/cookbook.html).